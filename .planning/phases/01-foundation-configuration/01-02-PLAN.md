---
phase: 01-foundation-configuration
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/cer_scraper/config/__init__.py
  - src/cer_scraper/config/settings.py
  - config/scraper.yaml
  - config/email.yaml
  - config/pipeline.yaml
  - .env.example
autonomous: true

must_haves:
  truths:
    - "Settings load from YAML files with correct default values"
    - "Environment variables override YAML values when set"
    - "Secrets are defined only in .env.example and loaded via env vars, never in YAML"
    - "Each config concern (scraper, email, pipeline) has its own YAML file and Settings class"
  artifacts:
    - path: "src/cer_scraper/config/settings.py"
      provides: "Pydantic settings models for scraper, email, and pipeline config"
      contains: "BaseSettings"
    - path: "config/scraper.yaml"
      provides: "Scraping settings (URLs, delays, pages)"
      contains: "base_url"
    - path: "config/email.yaml"
      provides: "Email settings (SMTP host, port, TLS)"
      contains: "smtp_host"
    - path: "config/pipeline.yaml"
      provides: "Pipeline settings (paths, timeouts, rotation)"
      contains: "db_path"
    - path: ".env.example"
      provides: "Template for required secret environment variables"
      contains: "EMAIL_APP_PASSWORD"
  key_links:
    - from: "src/cer_scraper/config/settings.py"
      to: "config/scraper.yaml"
      via: "pydantic-settings yaml_file source"
      pattern: "yaml_file.*scraper\\.yaml"
    - from: "src/cer_scraper/config/settings.py"
      to: ".env"
      via: "pydantic-settings env_file source"
      pattern: "env_file.*\\.env"
---

<objective>
Build the configuration system that loads settings from split YAML files and secrets from .env, providing typed, validated configuration objects to all downstream components.

Purpose: Every downstream phase needs configuration (URLs, paths, credentials, timeouts). This plan delivers the single source of truth for all settings, ensuring nothing is hardcoded.
Output: Three pydantic-settings models (ScraperSettings, EmailSettings, PipelineSettings), three YAML config files, and a .env.example template.
</objective>

<execution_context>
@C:\Users\amelv\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\amelv\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-configuration/01-RESEARCH.md
@.planning/phases/01-foundation-configuration/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pydantic-settings models</name>
  <files>
    src/cer_scraper/config/settings.py
    src/cer_scraper/config/__init__.py
  </files>
  <action>
Create `src/cer_scraper/config/settings.py` with three pydantic BaseSettings subclasses. Each class loads from its own YAML file and supports env var overrides.

**CRITICAL: Resolve config paths relative to project root, not CWD.** Define a `PROJECT_ROOT` constant using `Path(__file__).resolve().parents[3]` (which goes from `src/cer_scraper/config/settings.py` up to the repo root). All `yaml_file` and `env_file` paths must be resolved relative to this root. This prevents Pitfall 6 from RESEARCH.md (YAML files not found when run from a different working directory, e.g., Windows Task Scheduler).

**ScraperSettings:**
- `base_url: str` = "https://apps.cer-rec.gc.ca/REGDOCS"
- `recent_filings_path: str` = "/Search/RecentFilings"
- `delay_seconds: float` = 2.0
- `pages_to_scrape: int` = 1
- `user_agent: str` = "CER-Filing-Monitor/1.0"
- Source: `config/scraper.yaml`, env_prefix: `SCRAPER_`

**EmailSettings:**
- `smtp_host: str` = "smtp.gmail.com"
- `smtp_port: int` = 587
- `use_tls: bool` = True
- `sender_address: str` = "" (from .env: EMAIL_SENDER_ADDRESS)
- `app_password: str` = "" (from .env: EMAIL_APP_PASSWORD)
- `recipient_address: str` = "" (from .env: EMAIL_RECIPIENT_ADDRESS)
- Source: `config/email.yaml` + `.env`, env_prefix: `EMAIL_`

**PipelineSettings:**
- `data_dir: str` = "data"
- `db_path: str` = "data/state.db"
- `log_dir: str` = "logs"
- `log_max_bytes: int` = 10_485_760 (10MB)
- `log_backup_count: int` = 5
- `analysis_timeout_seconds: int` = 300
- `max_retry_count: int` = 3
- Source: `config/pipeline.yaml`, env_prefix: `PIPELINE_`

For each settings class, use `model_config = SettingsConfigDict(...)` with the appropriate `yaml_file` path (resolved to absolute path from PROJECT_ROOT) and `env_prefix`.

For EmailSettings specifically, also set `env_file` to the resolved `.env` path so it can load secrets.

Update `src/cer_scraper/config/__init__.py` to export a convenience function:

```python
from .settings import ScraperSettings, EmailSettings, PipelineSettings

def load_all_settings() -> tuple[ScraperSettings, EmailSettings, PipelineSettings]:
    """Load and return all configuration objects."""
    return ScraperSettings(), EmailSettings(), PipelineSettings()
```

**Source priority per RESEARCH.md:** env vars > .env file > YAML file > defaults. pydantic-settings handles this automatically when sources are configured correctly.

**Important:** Secrets (app_password, sender_address, recipient_address) must ONLY be loadable from environment variables or .env file. They must NOT have non-empty defaults and must NOT appear in YAML files. This is a locked user decision.
  </action>
  <verify>
Run: `uv run python -c "from cer_scraper.config.settings import ScraperSettings, PipelineSettings; s = ScraperSettings(); p = PipelineSettings(); print(f'base_url={s.base_url}'); print(f'db_path={p.db_path}'); print('Settings load OK')"`

This should print the default values from YAML (or built-in defaults if YAML files are not yet created -- Task 2 creates them).
  </verify>
  <done>Three settings classes exist, each loading from its own YAML file with env var override support. Secrets are only loadable from .env/env vars. load_all_settings() convenience function exported from config package.</done>
</task>

<task type="auto">
  <name>Task 2: Create YAML config files and .env.example</name>
  <files>
    config/scraper.yaml
    config/email.yaml
    config/pipeline.yaml
    .env.example
  </files>
  <action>
Create the `config/` directory and three YAML files with sensible defaults. These files are committed to version control (they contain NO secrets).

**config/scraper.yaml:**
```yaml
# CER REGDOCS scraper settings
base_url: "https://apps.cer-rec.gc.ca/REGDOCS"
recent_filings_path: "/Search/RecentFilings"
delay_seconds: 2.0
pages_to_scrape: 1
user_agent: "CER-Filing-Monitor/1.0"
```

**config/email.yaml:**
```yaml
# Email delivery settings (secrets in .env, NOT here)
smtp_host: "smtp.gmail.com"
smtp_port: 587
use_tls: true
# sender_address, app_password, recipient_address are in .env
```

**config/pipeline.yaml:**
```yaml
# Pipeline operational settings
data_dir: "data"
db_path: "data/state.db"
log_dir: "logs"
log_max_bytes: 10485760  # 10MB
log_backup_count: 5
analysis_timeout_seconds: 300
max_retry_count: 3
```

**.env.example:**
```bash
# .env.example -- Copy to .env and fill in real values
# NEVER commit .env to version control

# Email credentials (Gmail with app password)
EMAIL_SENDER_ADDRESS=your.email@gmail.com
EMAIL_APP_PASSWORD=xxxx-xxxx-xxxx-xxxx
EMAIL_RECIPIENT_ADDRESS=recipient@example.com
```

**Important:** The `email.yaml` file must contain a comment making it clear that secrets are in `.env`. This prevents future contributors from accidentally adding secrets to YAML.

After creating all files, verify the full config loading chain works end-to-end:

```bash
uv run python -c "
from cer_scraper.config import load_all_settings
scraper, email, pipeline = load_all_settings()
assert scraper.base_url == 'https://apps.cer-rec.gc.ca/REGDOCS'
assert scraper.delay_seconds == 2.0
assert email.smtp_host == 'smtp.gmail.com'
assert email.smtp_port == 587
assert pipeline.db_path == 'data/state.db'
assert pipeline.log_max_bytes == 10_485_760
print('All config files loaded and validated successfully')
"
```
  </action>
  <verify>
1. Run the end-to-end config loading test above -- must print success message
2. Confirm `config/email.yaml` does NOT contain any values for sender_address, app_password, or recipient_address
3. Confirm `.env.example` exists with all three EMAIL_* variables listed
  </verify>
  <done>Three YAML config files exist in config/ with correct defaults. .env.example documents required secrets. Config loading chain works: YAML values are read, validated by pydantic, and accessible as typed Python objects.</done>
</task>

</tasks>

<verification>
1. `uv run python -c "from cer_scraper.config import load_all_settings; s,e,p = load_all_settings(); print(f'{s.base_url} | {e.smtp_host} | {p.db_path}')"` prints correct values
2. No secrets appear in any YAML file (grep for "password" in config/*.yaml returns zero results)
3. `.env.example` contains EMAIL_SENDER_ADDRESS, EMAIL_APP_PASSWORD, EMAIL_RECIPIENT_ADDRESS
4. Environment variable override works: `SCRAPER_DELAY_SECONDS=5.0 uv run python -c "from cer_scraper.config.settings import ScraperSettings; print(ScraperSettings().delay_seconds)"` prints 5.0
</verification>

<success_criteria>
- Three pydantic-settings models load from three separate YAML files
- All default values match the RESEARCH.md specifications
- Secrets are exclusively in .env (never in YAML)
- Env var overrides work (higher priority than YAML)
- Config paths resolve correctly regardless of working directory
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-configuration/01-02-SUMMARY.md`
</output>
